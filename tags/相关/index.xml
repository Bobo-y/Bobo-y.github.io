<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>相关 on Lin Yang&#39;s Blog</title>
    <link>https://yl305237731.github.io/tags/%E7%9B%B8%E5%85%B3/</link>
    <description>Recent content in 相关 on Lin Yang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 20 Dec 2018 15:44:06 +0800</lastBuildDate>
    
	<atom:link href="https://yl305237731.github.io/tags/%E7%9B%B8%E5%85%B3/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>模版匹配之相关匹配</title>
      <link>https://yl305237731.github.io/post/pipei1/</link>
      <pubDate>Thu, 20 Dec 2018 15:44:06 +0800</pubDate>
      
      <guid>https://yl305237731.github.io/post/pipei1/</guid>
      <description>模板匹配 最近准备把学过的一些知识整理写成博客，加深印象。 模板匹配是一种最原始、最基本的模式识别方法，研究某一特定对象物的图案位于图像的什么地方，进而识别对象物，这就是一个匹配问题。它是图像处理中最基本、最常用的匹配方法。模板匹配具有自身的局限性，主要表现在它只能进行平行移动，若原图像中的匹配目标发生旋转或大小变化，该算法无效。
普通的模板匹配方法属于暴力搜索法，通过将模板图像不断在搜索图上移动，计算模板与模板覆盖区域子图像的相似度，显而易见，时间复杂度特别大。 相关法 相关法即计算模板与图像子区域的相关系数，相关系数也能反映出两张图片的相似度 计算公式： 对于模板 T(m,n),搜索图像 S(W,H),模板覆盖被搜索图的那块区域叫子图 $S_{ij}$, i,j 为子图在被搜索图中左上角的坐标, 模板高h,宽w, 1 =&amp;lt; i =&amp;lt; H-h, 1 =&amp;lt; j =&amp;lt; W-w, $$ R(i,j) = \frac{\sum {m=1}^{M}\sum{n=1}^{N}S_{ij}(m,n)* T(m,n)}{\sqrt{\sum {m=1}^{M}\sum{n=1}^{N}[S_{ij}(m,n)]^{2} \sum {m=1}^{M}\sum{n=1}^{N}[T(m,n)]^{2}}} $$
实验结果 1. 这是当时的一个作业 搜索图：
模板一： 模板2： 匹配结果如下： 两个模板都定位到同一目标，人眼可看出模板2和场景中定位出的目标匹配，模板1和定位出的并不是同一个，但是是最大的相似度，故匹配出
2 模板lena: very good.
代码 from PIL import Image import matplotlib.image as mpimg import matplotlib.pyplot as plt import numpy as np class templateMatch: x = 0 y = 0 flag = False def rgb2gray(self,src): if 3 == len(src.</description>
    </item>
    
  </channel>
</rss>