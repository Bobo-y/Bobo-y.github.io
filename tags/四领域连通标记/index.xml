<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>四领域连通标记 on Lin Yang&#39;s Blog</title>
    <link>https://yl305237731.github.io/tags/%E5%9B%9B%E9%A2%86%E5%9F%9F%E8%BF%9E%E9%80%9A%E6%A0%87%E8%AE%B0/</link>
    <description>Recent content in 四领域连通标记 on Lin Yang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 21 Sep 2018 17:01:55 +0800</lastBuildDate>
    
	<atom:link href="https://yl305237731.github.io/tags/%E5%9B%9B%E9%A2%86%E5%9F%9F%E8%BF%9E%E9%80%9A%E6%A0%87%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>图像联通区域标记</title>
      <link>https://yl305237731.github.io/post/coonectregion/</link>
      <pubDate>Fri, 21 Sep 2018 17:01:55 +0800</pubDate>
      
      <guid>https://yl305237731.github.io/post/coonectregion/</guid>
      <description>###由于最近做实验用到二值图像连通区域（八连通）标记，刚开始的时候为了验证算法有效性，用了递归的方法（太慢了，而且图像一大就容易栈溢出），最后查看了opencv和MATLAB的实现，做个记录。（为了简单说明，以下说明已四连通为例）
扫描法连通区域标记： 例：对于二值图像、四连通
第一次遍历： 1.建立一个和图像大小一样的矩阵保存结果，原图记为im,结果矩阵记为mask,mask各元素值可初始化为0. 从上到下，从左到右扫描原图像，变量Mark记录当前赋值 2.若当前访问像素坐标（i,j）且im[i,j]不为0，访问mask[i-1]j和mask[i,j-1]（若未越界）,二者若均为0，Mark++，赋值给当前坐标对应的mask. 若其中一个为0，将非0值赋值给mask[i][j]。 若均非0且相等，将mask[i][j]标记为同一类，若不等将二者最小值赋予mask[i][j],同时将二者合并为同一类（并查集）。
第二次遍历： 根据并查集的内容对区域赋值。
def countRegion(img): [high,width] = np.shape(img) mask = np.zeros_like(img) mark = 0 union = {} for i in range (high): for j in range(width): if i==0 and j==0: if img[i][j]==255: mark=mark+1 mask[i][j]=mark union[mark]=mark if i==0 and j!=0: if img[i][j]==255: left = mask[i][j-1] if left!=0: mask[i][j]=left else: mark = mark +1 mask[i][j]=mark union[mark]=mark if j==0 and i!=0: if img[i][j]==255: up = mask[i-1][j] up_right = mask[i-1][j+1] if up==0 and up_right==0: mark = mark+1 mask[i][j]=mark union[mark]=mark if up==0 and up_right!</description>
    </item>
    
  </channel>
</rss>