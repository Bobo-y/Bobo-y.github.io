<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on fly away, chase dream</title>
    <link>/categories/leetcode/</link>
    <description>Recent content in LeetCode on fly away, chase dream</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 07 Apr 2020 21:02:42 +0800</lastBuildDate>
    
	<atom:link href="/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode:1038</title>
      <link>/leetcode/leetcode1038.%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%B0%E6%9B%B4%E5%A4%A7%E5%92%8C%E6%A0%91/</link>
      <pubDate>Tue, 07 Apr 2020 21:02:42 +0800</pubDate>
      
      <guid>/leetcode/leetcode1038.%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%B0%E6%9B%B4%E5%A4%A7%E5%92%8C%E6%A0%91/</guid>
      <description>给出二叉 搜索 树的根节点，该二叉树的节点值各不相同，修改二叉树，使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列</description>
    </item>
    
    <item>
      <title>Excel列表字母数字转换</title>
      <link>/leetcode/excel%E5%88%97%E8%A1%A8%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 03 Apr 2020 12:55:05 +0800</pubDate>
      
      <guid>/leetcode/excel%E5%88%97%E8%A1%A8%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</guid>
      <description>给定一个Excel表格中的列名称，返回其相应的列序号 例如， A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... 26进制 int titleToNumber(string s) { if(s.size()==0) return 0; int len = s.size(); int res =0; for(int i=0; i&amp;lt;len;i++){</description>
    </item>
    
    <item>
      <title>数组中第K个最大元素</title>
      <link>/leetcode/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 01 Apr 2020 23:21:59 +0800</pubDate>
      
      <guid>/leetcode/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素 快排思想, 每次取一个划分位置,</description>
    </item>
    
    <item>
      <title>二叉树的最近邻祖先节点</title>
      <link>/leetcode/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E9%82%BB%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 01 Apr 2020 20:32:36 +0800</pubDate>
      
      <guid>/leetcode/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E9%82%BB%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/</guid>
      <description>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 二叉搜索树的性质, 父节点大于左节点小于右节点, 如果两个节点一个大于父节点的值一个小</description>
    </item>
    
    <item>
      <title>数组最大连续和</title>
      <link>/leetcode/%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C/</link>
      <pubDate>Wed, 01 Apr 2020 17:34:10 +0800</pubDate>
      
      <guid>/leetcode/%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C/</guid>
      <description>给一个数组, 其中元素有正有负, 求数组的连续最大和. 最直观的暴力法可解. 但不可行. 用两个数记录当前和以及当前最大值, 当当前和《=0时, 将当前和</description>
    </item>
    
    <item>
      <title>Three-sum</title>
      <link>/leetcode/three_sum/</link>
      <pubDate>Wed, 01 Apr 2020 17:04:12 +0800</pubDate>
      
      <guid>/leetcode/three_sum/</guid>
      <description>Three sum 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：</description>
    </item>
    
    <item>
      <title>最长公共前缀</title>
      <link>/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Wed, 01 Apr 2020 13:53:38 +0800</pubDate>
      
      <guid>/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;ldquo;。 每次对比两个串, 一旦不相等就跳出</description>
    </item>
    
    <item>
      <title>字符串转整数</title>
      <link>/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 01 Apr 2020 12:49:40 +0800</pubDate>
      
      <guid>/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      <description>请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到</description>
    </item>
    
    <item>
      <title>链表相加</title>
      <link>/leetcode/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Wed, 01 Apr 2020 00:58:17 +0800</pubDate>
      
      <guid>/leetcode/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</guid>
      <description>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字, 返回新的链表 ListNode* twoListSum(ListNode* l1,</description>
    </item>
    
    <item>
      <title>数字反转</title>
      <link>/leetcode/%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Wed, 01 Apr 2020 00:54:21 +0800</pubDate>
      
      <guid>/leetcode/%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC/</guid>
      <description>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 超过32为的最大整数, 返回0 用long型来标记溢出, 利用如果溢出long转</description>
    </item>
    
    <item>
      <title>用rand5模拟rand7</title>
      <link>/leetcode/%E7%94%A8rand5%E6%A8%A1%E6%8B%9Frand7/</link>
      <pubDate>Mon, 30 Mar 2020 23:36:49 +0800</pubDate>
      
      <guid>/leetcode/%E7%94%A8rand5%E6%A8%A1%E6%8B%9Frand7/</guid>
      <description>rand5 函数可以等概率随机产生1-5五个数, 要求用 rand5 模拟出rand7. 考虑以rand7 实现rand5 def rand5(): res=6 while(res&amp;gt;5): res=random.randint(1,7) return res 验证是否生成的数字是等概率生成1</description>
    </item>
    
    <item>
      <title>旋转数组最小数字</title>
      <link>/leetcode/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 30 Mar 2020 22:35:00 +0800</pubDate>
      
      <guid>/leetcode/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid>
      <description>给定一个一个排序数组, 将前端部分数字放到数组尾部, 求出数组中的最小数字, [4,5,6,1,2,3] 返回1. 对于有序数组, 考虑使用二分查找法. 当 arr[mid] &amp;gt; arr[high] 时, 最小值必在【</description>
    </item>
    
    <item>
      <title>动态规划集合</title>
      <link>/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 28 Mar 2020 22:16:54 +0800</pubDate>
      
      <guid>/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9B%86%E5%90%88/</guid>
      <description>动态规划,提起来就头大┭┮﹏┭┮, 以本文记录常考的动态规划算法 在问题满足动态规划求解的时候, 动态规划主要靠维护一个数组来记录状态转移值, 只要</description>
    </item>
    
    <item>
      <title>数组中数字出现的次数</title>
      <link>/leetcode/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Fri, 27 Mar 2020 18:20:03 +0800</pubDate>
      
      <guid>/leetcode/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid>
      <description>给定一个数组, 假设其中有两个数只出现了一次, 其它均出现了两次, 让找出只出现了一次的两个数字. 对于数字出现次数, 可从异或角度出发. 当数组中只有</description>
    </item>
    
    <item>
      <title>字符串全排列</title>
      <link>/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Fri, 27 Mar 2020 15:16:15 +0800</pubDate>
      
      <guid>/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>给定字符串, 输出或统计全排列个数. 并去重 void judge(char* p, char* P1){ while(p&amp;lt;p1){ if(*p==*p1) return true; } return false; } void permutation(char* orig, char* ind_cur){ if(*ind_cur==&#39;\0&#39;) cout&amp;lt;&amp;lt;orig&amp;lt;&amp;lt;endl; else{ for(char* p=ind_cur;p!=&#39;\0&#39;;p++){ if(judge(ind_cur, p)) continue; char temp = *p; *p=*ind_cur; *ind_cur=temp; permutation(orig, ind_cur+1); temp=*p; *p=*ind_cur; *ind_cur=temp; } } } void permutation(char* str){ if(str==nullptr) return; permutation(str,str); }</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 25 Mar 2020 18:39:38 +0800</pubDate>
      
      <guid>/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>树节点 struct TreeNode{ int val; TreeNode * left, * right; TreeNode(int val){ this-&amp;gt;val = val; this-&amp;gt;left=nullptr; this-&amp;gt;right= nullptr; } }; 二叉树前中后序遍历递归非递归 // 递归实现 void pre_order(TreeNode * head){ if(head==nullptr) return; cout&amp;lt;&amp;lt;head-&amp;gt;val&amp;lt;&amp;lt;endl; if(head-&amp;gt;left) pre_order(head-&amp;gt;left); if(head-&amp;gt;right) pre_order(head-&amp;gt;right); } void in_order(TreeNode * head){ if(head-&amp;gt;left) in_order(head-&amp;gt;left); cout&amp;lt;&amp;lt;head-&amp;gt;val&amp;lt;&amp;lt;endl; if(head-&amp;gt;right) in_order(head-&amp;gt;right); } void post_order(TreeNode * head){ if(head-&amp;gt;left) post_order(head-&amp;gt;left); if(head-&amp;gt;right)</description>
    </item>
    
    <item>
      <title>堆排序以及topk问题</title>
      <link>/leetcode/%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 25 Mar 2020 15:10:37 +0800</pubDate>
      
      <guid>/leetcode/%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>大根堆排序流程: 建堆, 构建二叉树, 父节点均大于子节点 将堆首元素与堆尾元素交换 重新调整堆, 不包含堆尾元素 void adjustHeap(std::vector&amp;lt;int&amp;gt; &amp;amp;arr, int p_ind, int size){ int l_child = 2 * p_ind + 1; while(l_child &amp;lt; size){ if(l_child</description>
    </item>
    
    <item>
      <title>LeetCode:开方函数sqrt实现</title>
      <link>/leetcode/lettcode%E5%BC%80%E6%96%B9%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 10 Mar 2019 15:30:15 +0800</pubDate>
      
      <guid>/leetcode/lettcode%E5%BC%80%E6%96%B9%E5%87%BD%E6%95%B0/</guid>
      <description>要求实现开方函数，面试时这个问题出现的次数还是比较多的。 一：二分查找法 对于一个给定的非负数A，它的平方根都不会大于[A/2+1],故在[0,</description>
    </item>
    
  </channel>
</rss>