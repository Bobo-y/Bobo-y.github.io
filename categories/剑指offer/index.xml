<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>剑指offer on 扬帆起航</title>
    <link>/categories/%E5%89%91%E6%8C%87offer/</link>
    <description>Recent content in 剑指offer on 扬帆起航</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 02 Apr 2019 21:41:09 +0800</lastBuildDate>
    
	<atom:link href="/categories/%E5%89%91%E6%8C%87offer/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>剑指offer10:斐波那契数列</title>
      <link>/post/%E5%89%91%E6%8C%87offer10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Tue, 02 Apr 2019 21:41:09 +0800</pubDate>
      
      <guid>/post/%E5%89%91%E6%8C%87offer10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description>(adsbygoogle = window.adsbygoogle || []).push({}); 题目一： 求斐波那契数列的第n项. 斐波那契数列公式： $$f(0)=0$$ $$f(1)=1$$ $$f(n)=f(n-1) + f(n-2),n&amp;gt;1$$ 对于斐波那契数列，学过程序语言的应该都知道. 教学时基本都是使用它来说明</description>
    </item>
    
    <item>
      <title>剑指offer9:两个栈实现队列</title>
      <link>/post/%E5%89%91%E6%8C%87offer9_%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Fri, 22 Mar 2019 22:44:49 +0800</pubDate>
      
      <guid>/post/%E5%89%91%E6%8C%87offer9_%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>(adsbygoogle = window.adsbygoogle || []).push({}); 题目：用两个栈实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路：队列的特点是先进先出，单个栈为先进后出</description>
    </item>
    
    <item>
      <title>剑指offer6:逆向打印链表</title>
      <link>/post/%E5%89%91%E6%8C%87offer6/</link>
      <pubDate>Sat, 09 Mar 2019 23:40:45 +0800</pubDate>
      
      <guid>/post/%E5%89%91%E6%8C%87offer6/</guid>
      <description>(adsbygoogle = window.adsbygoogle || []).push({}); 问题描述：输入一个链表的头节点，反向打印出链表. 链表结构如下 struct ListNode { int val; ListNode *next; ListNode(int x): val(x), next(NULL){ } }; 思路：链表反向打印，先进后出，考虑使用栈. class</description>
    </item>
    
    <item>
      <title>剑指offer4：二维数组中的查找</title>
      <link>/post/%E5%89%91%E6%8C%87offer4/</link>
      <pubDate>Sun, 03 Mar 2019 20:36:38 +0800</pubDate>
      
      <guid>/post/%E5%89%91%E6%8C%87offer4/</guid>
      <description>(adsbygoogle = window.adsbygoogle || []).push({}); 问题描述：在一个二维数组中，每一行都按从做到右递增顺序排序，每一列都按从上到下递增顺序排序。输入一个二维数组与一个整数，判断数组中</description>
    </item>
    
    <item>
      <title>剑指offer3: 数组重复数字</title>
      <link>/post/%E5%89%91%E6%8C%87offer_%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 02 Mar 2019 16:52:59 +0800</pubDate>
      
      <guid>/post/%E5%89%91%E6%8C%87offer_%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</guid>
      <description>(adsbygoogle = window.adsbygoogle || []).push({}); 题目描述：在一个长度为n的数组里的所有数字都在0～n-1之间。数组中某些数字时重复的，但不知道有几个重复了，也不知道每个数字重复了</description>
    </item>
    
    <item>
      <title>剑指offer7:重构二叉树</title>
      <link>/post/%E5%89%91%E6%8C%87offer7/</link>
      <pubDate>Fri, 01 Mar 2019 19:10:54 +0800</pubDate>
      
      <guid>/post/%E5%89%91%E6%8C%87offer7/</guid>
      <description>(adsbygoogle = window.adsbygoogle || []).push({}); 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序</description>
    </item>
    
  </channel>
</rss>