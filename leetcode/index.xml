<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcodes on fly away, chase dream</title>
    <link>/leetcode/</link>
    <description>Recent content in Leetcodes on fly away, chase dream</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 03 Apr 2020 12:55:05 +0800</lastBuildDate>
    
	<atom:link href="/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Excel列表字母数字转换</title>
      <link>/leetcode/excel%E5%88%97%E8%A1%A8%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 03 Apr 2020 12:55:05 +0800</pubDate>
      
      <guid>/leetcode/excel%E5%88%97%E8%A1%A8%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</guid>
      <description>给定一个Excel表格中的列名称，返回其相应的列序号 例如， A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... 26进制 int titleToNumber(string s) { if(s.size()==0) return 0; int len = s.size(); int res =0; for(int i=0; i&amp;lt;len;i++){</description>
    </item>
    
    <item>
      <title>数组中第K个最大元素</title>
      <link>/leetcode/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 01 Apr 2020 23:21:59 +0800</pubDate>
      
      <guid>/leetcode/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素 快排思想, 每次取一个划分位置,</description>
    </item>
    
    <item>
      <title>二叉树的最近邻祖先节点</title>
      <link>/leetcode/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E9%82%BB%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 01 Apr 2020 20:32:36 +0800</pubDate>
      
      <guid>/leetcode/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E9%82%BB%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/</guid>
      <description>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 二叉搜索树的性质, 父节点大于左节点小于右节点, 如果两个节点一个大于父节点的值一个小</description>
    </item>
    
    <item>
      <title>数组最大连续和</title>
      <link>/leetcode/%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C/</link>
      <pubDate>Wed, 01 Apr 2020 17:34:10 +0800</pubDate>
      
      <guid>/leetcode/%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C/</guid>
      <description>给一个数组, 其中元素有正有负, 求数组的连续最大和. 最直观的暴力法可解. 但不可行. 用两个数记录当前和以及当前最大值, 当当前和《=0时, 将当前和</description>
    </item>
    
    <item>
      <title>Three-sum</title>
      <link>/leetcode/three_sum/</link>
      <pubDate>Wed, 01 Apr 2020 17:04:12 +0800</pubDate>
      
      <guid>/leetcode/three_sum/</guid>
      <description>Three sum 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：</description>
    </item>
    
    <item>
      <title>最长公共前缀</title>
      <link>/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Wed, 01 Apr 2020 13:53:38 +0800</pubDate>
      
      <guid>/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;ldquo;。 每次对比两个串, 一旦不相等就跳出</description>
    </item>
    
    <item>
      <title>字符串转整数</title>
      <link>/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 01 Apr 2020 12:49:40 +0800</pubDate>
      
      <guid>/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      <description>请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到</description>
    </item>
    
    <item>
      <title>链表相加</title>
      <link>/leetcode/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Wed, 01 Apr 2020 00:58:17 +0800</pubDate>
      
      <guid>/leetcode/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</guid>
      <description>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字, 返回新的链表 ListNode* twoListSum(ListNode* l1,</description>
    </item>
    
    <item>
      <title>数字反转</title>
      <link>/leetcode/%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Wed, 01 Apr 2020 00:54:21 +0800</pubDate>
      
      <guid>/leetcode/%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC/</guid>
      <description>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 超过32为的最大整数, 返回0 用long型来标记溢出, 利用如果溢出long转</description>
    </item>
    
    <item>
      <title>用rand5模拟rand7</title>
      <link>/leetcode/%E7%94%A8rand5%E6%A8%A1%E6%8B%9Frand7/</link>
      <pubDate>Mon, 30 Mar 2020 23:36:49 +0800</pubDate>
      
      <guid>/leetcode/%E7%94%A8rand5%E6%A8%A1%E6%8B%9Frand7/</guid>
      <description>rand5 函数可以等概率随机产生1-5五个数, 要求用 rand5 模拟出rand7. 考虑以rand7 实现rand5 def rand5(): res=6 while(res&amp;gt;5): res=random.randint(1,7) return res 验证是否生成的数字是等概率生成1</description>
    </item>
    
    <item>
      <title>旋转数组最小数字</title>
      <link>/leetcode/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 30 Mar 2020 22:35:00 +0800</pubDate>
      
      <guid>/leetcode/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid>
      <description>给定一个一个排序数组, 将前端部分数字放到数组尾部, 求出数组中的最小数字, [4,5,6,1,2,3] 返回1. 对于有序数组, 考虑使用二分查找法. 当 arr[mid] &amp;gt; arr[high] 时, 最小值必在【</description>
    </item>
    
    <item>
      <title>动态规划集合</title>
      <link>/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 28 Mar 2020 22:16:54 +0800</pubDate>
      
      <guid>/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9B%86%E5%90%88/</guid>
      <description>动态规划,提起来就头大┭┮﹏┭┮, 以本文记录常考的动态规划算法 在问题满足动态规划求解的时候, 动态规划主要靠维护一个数组来记录状态转移值, 只要</description>
    </item>
    
    <item>
      <title>数组中数字出现的次数</title>
      <link>/leetcode/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Fri, 27 Mar 2020 18:20:03 +0800</pubDate>
      
      <guid>/leetcode/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid>
      <description>给定一个数组, 假设其中有两个数只出现了一次, 其它均出现了两次, 让找出只出现了一次的两个数字. 对于数字出现次数, 可从异或角度出发. 当数组中只有</description>
    </item>
    
    <item>
      <title>字符串全排列</title>
      <link>/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Fri, 27 Mar 2020 15:16:15 +0800</pubDate>
      
      <guid>/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>给定字符串, 输出或统计全排列个数. 并去重 void judge(char* p, char* P1){ while(p&amp;lt;p1){ if(*p==*p1) return true; } return false; } void permutation(char* orig, char* ind_cur){ if(*ind_cur==&#39;\0&#39;) cout&amp;lt;&amp;lt;orig&amp;lt;&amp;lt;endl; else{ for(char* p=ind_cur;p!=&#39;\0&#39;;p++){ if(judge(ind_cur, p)) continue; char temp = *p; *p=*ind_cur; *ind_cur=temp; permutation(orig, ind_cur+1); temp=*p; *p=*ind_cur; *ind_cur=temp; } } } void permutation(char* str){ if(str==nullptr) return; permutation(str,str); }</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 25 Mar 2020 18:39:38 +0800</pubDate>
      
      <guid>/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>树节点 struct TreeNode{ int val; TreeNode * left, * right; TreeNode(int val){ this-&amp;gt;val = val; this-&amp;gt;left=nullptr; this-&amp;gt;right= nullptr; } }; 二叉树前中后序遍历递归非递归 // 递归实现 void pre_order(TreeNode * head){ if(head==nullptr) return; cout&amp;lt;&amp;lt;head-&amp;gt;val&amp;lt;&amp;lt;endl; if(head-&amp;gt;left) pre_order(head-&amp;gt;left); if(head-&amp;gt;right) pre_order(head-&amp;gt;right); } void in_order(TreeNode * head){ if(head-&amp;gt;left) in_order(head-&amp;gt;left); cout&amp;lt;&amp;lt;head-&amp;gt;val&amp;lt;&amp;lt;endl; if(head-&amp;gt;right) in_order(head-&amp;gt;right); } void post_order(TreeNode * head){ if(head-&amp;gt;left) post_order(head-&amp;gt;left); if(head-&amp;gt;right)</description>
    </item>
    
    <item>
      <title>堆排序以及topk问题</title>
      <link>/leetcode/%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 25 Mar 2020 15:10:37 +0800</pubDate>
      
      <guid>/leetcode/%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>大根堆排序流程: 建堆, 构建二叉树, 父节点均大于子节点 将堆首元素与堆尾元素交换 重新调整堆, 不包含堆尾元素 void adjustHeap(std::vector&amp;lt;int&amp;gt; &amp;amp;arr, int p_ind, int size){ int l_child = 2 * p_ind + 1; while(l_child &amp;lt; size){ if(l_child</description>
    </item>
    
    <item>
      <title>剑指offer23:链表中环的入口地址</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer23%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Sun, 07 Apr 2019 18:53:24 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer23%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80/</guid>
      <description>题目：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null 思路：链表存在环，则没有尾节点. 对于链表一个指针无法解决时，考</description>
    </item>
    
    <item>
      <title>剑指offer52:两个链表的第一个公共节点</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sun, 07 Apr 2019 15:33:31 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>题目：输入两个链表，找出它们的第一个公共结点 思路：暴力法时间复杂度O(n^2). 当两个链表具有公共节点时，第一个公共节点之后的节点全部相等.</description>
    </item>
    
    <item>
      <title>剑指offer55:二叉树的深度</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sat, 06 Apr 2019 23:03:12 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目一：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度 思路：求树的深</description>
    </item>
    
    <item>
      <title>剑指offer32:从上到下打印二叉树</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 05 Apr 2019 23:53:14 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印 思路：典型的队列使用 void PrintFromTopToBottom(TreeNode* root) { if(root==nullptr) return ; queue&amp;lt;TreeNode*&amp;gt; q; q.push(root); while(!q.empty()){ TreeNode* node = q.front(); q.pop(); cout&amp;lt;&amp;lt;node-&amp;gt;val&amp;lt;&amp;lt;&amp;quot; &amp;quot;; if(node-&amp;gt;left!=nullptr) q.push(node-&amp;gt;left); if(node-&amp;gt;right!=nullptr) q.push(node-&amp;gt;right); } } 拓展1： 分层从</description>
    </item>
    
    <item>
      <title>剑指offer30:包含min函数的栈</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link>
      <pubDate>Fri, 05 Apr 2019 23:25:09 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid>
      <description>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1）. 思路：对于栈，要在O(1)时间内获</description>
    </item>
    
    <item>
      <title>剑指offer12:矩阵中的路径</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Fri, 05 Apr 2019 22:51:22 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左</description>
    </item>
    
    <item>
      <title>剑指offer27:树的镜像</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer27%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Thu, 04 Apr 2019 23:52:48 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer27%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>题目：操作给定的二叉树，将其变换为源二叉树的镜像 如上图所示，树的镜像是将每个节点的左右子树交换，因此，对于每个节点只需要交换左右子树的指针，</description>
    </item>
    
    <item>
      <title>剑指offer26:树的子结构</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 04 Apr 2019 22:58:37 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>题目:输入两棵二叉树A，B，判断B是不是A的子结构. 如上图，其中B为A的子结构. 思路: 判断是否为子树，首先需要定位到子树的根节点，然后对两颗</description>
    </item>
    
    <item>
      <title>剑指offer25:合并两个排序的链表</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 03 Apr 2019 16:58:07 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则. 思路：对于两个递增的链表合并，合并后仍递增</description>
    </item>
    
    <item>
      <title>剑指offer24:反转链表</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 03 Apr 2019 00:43:52 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>题目：输入一个链表，反转链表后，输出新链表的表头. 思路一：链表反转，需将节点指向改变. 可以每次取下一个节点向之前的节点中插入，采用头插法实现</description>
    </item>
    
    <item>
      <title>剑指offer22:链表倒数第k个节点</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer22%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 02 Apr 2019 22:44:44 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer22%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>题目：输入一个链表，输出该链表中倒数第k个结点. 链表长度未知，可以西安遍历一次得到链表长度，然后可计算出移动多少步. 然后这样做相当于遍历两次</description>
    </item>
    
    <item>
      <title>剑指offer10:斐波那契数列</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Tue, 02 Apr 2019 21:41:09 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer10_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description>题目一： 求斐波那契数列的第n项. 斐波那契数列公式： $$f(0)=0$$ $$f(1)=1$$ $$f(n)=f(n-1) + f(n-2),n&amp;gt;1$$ 对于斐波那契数列，学过程序语言的应该都知道. 教学时基本都是使用它来说明递归，导致</description>
    </item>
    
    <item>
      <title>剑指offer21:调整数组顺序使奇数位于偶数前</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D/</link>
      <pubDate>Mon, 01 Apr 2019 23:33:15 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D/</guid>
      <description>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使所有奇数位于数组的前半部分，所有偶数位于数组后半部分. 思路：交换数组元素，若</description>
    </item>
    
    <item>
      <title>剑指offer9:两个栈实现队列</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer9_%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Fri, 22 Mar 2019 22:44:49 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer9_%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>题目：用两个栈实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路：队列的特点是先进先出，单个栈为先进后出。 class Solution { public:</description>
    </item>
    
    <item>
      <title>LeetCode:开方函数sqrt实现</title>
      <link>/leetcode/lettcode%E5%BC%80%E6%96%B9%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 10 Mar 2019 15:30:15 +0800</pubDate>
      
      <guid>/leetcode/lettcode%E5%BC%80%E6%96%B9%E5%87%BD%E6%95%B0/</guid>
      <description>要求实现开方函数，面试时这个问题出现的次数还是比较多的。 一：二分查找法 对于一个给定的非负数A，它的平方根都不会大于[A/2+1],故在[0,</description>
    </item>
    
    <item>
      <title>剑指offer6:逆向打印链表</title>
      <link>/leetcode/%E9%80%86%E5%90%91%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 09 Mar 2019 23:40:45 +0800</pubDate>
      
      <guid>/leetcode/%E9%80%86%E5%90%91%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>问题描述：输入一个链表的头节点，反向打印出链表. 链表结构如下 struct ListNode { int val; ListNode *next; ListNode(int x): val(x), next(NULL){ } }; 思路：链表反向打印，先进后出，考虑使用栈. class Solution { public: void printListFromTailToHead(ListNode*</description>
    </item>
    
    <item>
      <title>剑指offer16:数字的整数次方</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer16%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</link>
      <pubDate>Thu, 07 Mar 2019 22:04:04 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer16%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</guid>
      <description>题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和expon</description>
    </item>
    
    <item>
      <title>剑指offer15:二进制中1的个数</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Tue, 05 Mar 2019 22:19:22 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>题目： 请实现一个函数，输入一个整数，输出该二进制中表示1的个数. 对于二进制运算，主要是按位与、或、非. 1与1相与为1，1与0相与为0. 因此,</description>
    </item>
    
    <item>
      <title>剑指offer4：二维数组中的查找</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer4%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 03 Mar 2019 20:36:38 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer4%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>问题描述：在一个二维数组中，每一行都按从做到右递增顺序排序，每一列都按从上到下递增顺序排序。输入一个二维数组与一个整数，判断数组中是否有这个</description>
    </item>
    
    <item>
      <title>剑指offer3: 数组重复数字</title>
      <link>/leetcode/%E5%89%91%E6%8C%87offer_%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 02 Mar 2019 16:52:59 +0800</pubDate>
      
      <guid>/leetcode/%E5%89%91%E6%8C%87offer_%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</guid>
      <description>题目描述：在一个长度为n的数组里的所有数字都在0～n-1之间。数组中某些数字时重复的，但不知道有几个重复了，也不知道每个数字重复了几次。请找</description>
    </item>
    
    <item>
      <title>剑指offer7:重构二叉树</title>
      <link>/leetcode/%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 01 Mar 2019 19:10:54 +0800</pubDate>
      
      <guid>/leetcode/%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{</description>
    </item>
    
  </channel>
</rss>